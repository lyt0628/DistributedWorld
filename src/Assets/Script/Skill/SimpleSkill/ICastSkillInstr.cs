


using QS.Api.Executor.Domain;
using QS.Skill.SimpleSkill;

namespace QS.Api.Skill.Domain.Instruction
{
        //指令里面需要携带技能定义吗???不需要
        // 一个技能都对应一个类实现吗, 也不必要
        // 给Skill分个类
        // Buff 类 : 对Combator的战斗数据提供增益 所有作用都用于CombatData中 如果一个Buff有时间限制, 这个责任属于谁? 我把责任交给外部, 我希望计算的部分尽可能简单
        // 控制技能: 对Combat 以外的数据进行影响,(这部分数据要不要也放到CombatData中呢??) 暂且不做这部分定义
        // 攻击技能: 进行攻击的技能, 最基本攻击检测的方式是 射线检测 和 碰撞体(静止的和动态的)
        // 最重要的部分是, 释放这个技能所必须得元数据是什么.
        // 为了提高内聚性, 技能必须做如下几件事情:
        // 1. 告诉处理器技能对应的角色动画是什么, 按策略分成单一动画Clip和分阶段的动画Clip,这两个的处理方式不一样, 使用策略模式解耦,以便复合更复杂的动画处理
        // 2. 告诉处理器技能的检测到的受击对象(或者检测方法, 比如说, 静止碰撞体的检测方式, Skill得把碰撞体的引用返回, 这个碰撞体提供检测,然后按流返回检测到的数据),
        // 技能初始化时由创造者提供必须的源数据
        // 3. 告诉处理器技能需要创建的粒子特效是什么,同样的, 按表现划分和 1 是一样的处理, 要不要合并处理呢???
        // 4. 告诉处理器具体的伤害值, 这个是由CombatData计算来的, 这个CombatData 由 处理器提供
        // 5. 告诉处理器具体的动画控制(不启用根骨骼动画的情况下), 具体的处理 由Control模块提供支持(得让Control模块提供接口才行)
        // 

        interface ICastSkillInstr : IInstruction 
        {
        // 只有Key的不算OOP，Handler必要能蛲ㄟ^Key拿到完整的Skill
        ISkill Skill { get; }
        }
}